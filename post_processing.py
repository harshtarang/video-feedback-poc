import json, re, string
import pandas as pd

MAX_NUM_AUDIO_FEEDBACK = float("inf")
MAX_NUM_TEXT_FEEDBACK = float("inf")
MAX_NUM_QUALITY_FEEDBACK = float("inf")
COLUMNS = ["id", "time", "sentence"]


## Clean the PAUSE, FREQUENCE and PACE annotations from LLM Feedback
def extract_tags_and_clean(text):
    # Extract everything between < and >
    tags = re.findall(r"<(.*?)>", text)

    # Remove all <...> from the string
    cleaned = re.sub(r"<.*?>", "", text).strip()
    cleaned = re.sub(r"\s+", " ", cleaned).strip()

    return tags, cleaned

def remove_units(text):
    units = r'(?:syl/sec|s|seconds|second|Hz|Hertz|syllables/sec|syllables per second|syllables/second)'
    pattern = rf'\b(?:was|is|of)\s*\d*\.?\d+\s*{units}(?:\s+which)?'
    text = re.sub(pattern, '', text)
    return re.sub(r'\s+', ' ', text).strip()

## Get time interval of feedback
## Sometimes "id" generated by LLM does not correspond to the actual sentence_id containing the "phrase". so we search and get the "actual_id"
def select_feedback(fdbck, sentence_df, fdbck_type, max_feedback):
    final_feedback = []

    for fb in fdbck:
        req_id = fb["id"]
        phrase = fb["phrase"]
        attributes, phrase = extract_tags_and_clean(phrase)
        phrase = phrase.translate(str.maketrans("", "", string.punctuation)).lower()
        time_int = None
        actual_id = None
        prev_id, post_id = req_id, req_id
        while True:
            if prev_id >= 0 and prev_id < len(sentence_df):
                dfr = sentence_df[sentence_df["id"] == prev_id]
                sentence = (
                    dfr["sentence"]
                    .iloc[0]
                    .translate(str.maketrans("", "", string.punctuation))
                    .lower()
                )
                if phrase in sentence:
                    time_int = dfr["time"].iloc[0]
                    actual_id = prev_id

                    break
            if prev_id != post_id and post_id >= 0 and post_id < len(sentence_df):
                dfr = sentence_df[sentence_df["id"] == post_id]
                sentence = (
                    dfr["sentence"]
                    .iloc[0]
                    .translate(str.maketrans("", "", string.punctuation))
                    .lower()
                )
                if phrase in sentence:
                    time_int = dfr["time"].iloc[0]
                    actual_id = post_id

                    break
            prev_id = prev_id - 1
            post_id = post_id + 1
            if prev_id < 0 and post_id >= len(sentence_df):
                break
        if time_int is not None:
            start_time = int(time_int.split("-")[0].strip())
            end_time = int(time_int.split("-")[1].strip())
            curr_fdbck = {
                "time": time_int,
                "phrase": phrase,
                "feedback": remove_units(fb["feedback"]),
                "score": fb["score"],
                "id": actual_id,
                "attributes": attributes,
                "type": fdbck_type + "_" + fb["attribute"],
                "type_display": map_feedback_type(fdbck_type, fb["attribute"]),
                "start_time": start_time,
                "end_time": end_time,
            }
            if "tip" in fb:
                curr_fdbck["tip"] = fb["tip"]
            final_feedback.append(curr_fdbck)
        if len(final_feedback) == max_feedback:
            break
    return final_feedback

def map_feedback_type(feedback_type, attribute=None):
    if feedback_type == "audio":
        if attribute == "pace":
            return "🔊 Pacing"
        else:
            return "🗝️ Stress on keywords"
    
    if feedback_type == "text":
        return "📝 Text Exactness"
    
    return "🗣️ Speech Fluency"

def process_llm_feedback(feedback, sen_df, feedback_type, max_num_feedback):
    with open(feedback) as f:
        response = f.read()
        try:
            content = json.loads(response.split("```json")[1].split("```")[0].strip())
        except:
            content = json.loads(response)

    if feedback_type == "audio" or feedback_type == "text":
        pos_fdbck = content["positive_feedback"]
        pos_fdbck = sorted(pos_fdbck, key=lambda x: x["score"], reverse=True)

        neg_fdbck = content["negative_feedback"]
        neg_fdbck = sorted(neg_fdbck, key=lambda x: x["score"], reverse=True)

        final_pos_feedback = select_feedback(
            pos_fdbck, sen_df, feedback_type, max_num_feedback
        )
        final_neg_feedback = select_feedback(
            neg_fdbck, sen_df, feedback_type, max_num_feedback
        )
        return final_pos_feedback, final_neg_feedback
    if feedback_type == "quality":
        q_fdbck = content["quality_feedback"]
        final_q_feedback = select_feedback(
            q_fdbck, sen_df, feedback_type, max_num_feedback
        )
        return final_q_feedback


def feedback_json_to_markdown(pos_feedback, neg_feedback):
    pos_feedback_text = "### Positive Feedback\n"
    neg_feedback_text = "### Negative Feedback\n"

    if pos_feedback:
        for fb in pos_feedback:
            pos_feedback_text += f"- **Time**: {fb['time']}, **Phrase**: {fb['phrase']}, **Feedback**: {fb['feedback']}, **Score**: {fb['score']}"
            if "tip" in fb:
                pos_feedback_text += f"  - Tip: {fb['tip']}\n"
    else:
        pos_feedback_text += "No positive feedback available.\n"

    if neg_feedback:
        for fb in neg_feedback:
            neg_feedback_text += f"- **Time**: {fb['time']}, **Phrase**: {fb['phrase']}, **Feedback**: {fb['feedback']}, **Score**: {fb['score']}"
            if "tip" in fb:
                neg_feedback_text += f"  - Tip: {fb['tip']}\n"
    else:
        neg_feedback_text += "No negative feedback available.\n"

    return pos_feedback_text + "\n" + neg_feedback_text


def collate_all_feedback(
    sentence_transcript, audio_feedback, text_feedback, quality_feedback
):

    # sentence_transcript = "artifacts/transcriptions/sentence_level_transcription_Dupha_AV4.txt"
    ## Convert sentence transcription to df
    with open(sentence_transcript) as f:
        lines = f.readlines()
        lines = [x.split("seconds>") for x in lines]
        lines = [x[0].split(">: <") + [x[1].strip()] for x in lines]

    sentence_df = pd.DataFrame(lines, columns=COLUMNS)
    sentence_df["id"] = sentence_df["id"].apply(
        lambda x: int(x.replace("<SID ", "").strip())
    )
    sentence_df["time"] = sentence_df["time"].apply(lambda x: x.strip())
    sentence_df["start_time"] = sentence_df["time"].apply(
        lambda x: int(x.split("-")[0].strip())
    )
    sentence_df["end_time"] = sentence_df["time"].apply(
        lambda x: int(x.split("-")[1].strip())
    )

    pos_aud, neg_aud = process_llm_feedback(
        audio_feedback, sentence_df, "audio", MAX_NUM_AUDIO_FEEDBACK
    )
    pos_txt, neg_txt = process_llm_feedback(
        text_feedback, sentence_df, "text", MAX_NUM_AUDIO_FEEDBACK
    )
    neg_q = process_llm_feedback(
        quality_feedback, sentence_df, "quality", MAX_NUM_AUDIO_FEEDBACK
    )

    pos_feedback = pos_aud + pos_txt
    neg_feedback = neg_aud + neg_txt + neg_q

    # return feedback_json_to_markdown(pos_feedback, neg_feedback)
    return pos_feedback, neg_feedback
